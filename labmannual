 
 

Program 1: 
Write a program to read data from the standard input device and write it 
on the screen(using read()/write() system calls) 

Syntax: 
#include<unistd.h> 
ssize_t read(int fd,const void  *buf,size_t count); 
The first parameter is the file descriptor. The second parameter is the buffer where the 
read data will be saved. Lastly, the third parameter is the number of bytes that is  to be read. 
V Semester 
 
 
 
Program: 
 
#include<unistd.h> 
int main() 
{ 
int nread; 
char buff[20]; 
nread=read(0,buff,10);//read 10 bytes from standard input device(keyboard) and store it  
                                               in buffer(buff) 
write (1,buff,nread);//print 10 bytes from the buffer on the screen 
} 
 
Commands: 
cc  filename.c 
./a.out 
 
Pesce mandya 
Pesce mandya 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Operating System (Intergrated)Lab Manual- P21CS504 
Program 2: 
Write a program to print 10 characters starting from the 10th character from a 
file(lseek() system call) 

Syntax: 
#include<sys/types.h> 
#include<unistd.h> 
off_t lseek (int fd,off_t offset,int whence); 
The first parameter is the file descriptor of the file, which you can get using open () system 
call.  
The second parameter specifies how much the pointer is to be moved.  
The third parameter is the reference point of the movement i.e., beginning of 
file(SEEK_SET),current position(SEEK_CUR) of pointer or end of file(SEEK_END). 
Examples: 
• lseek(fd,5,SEEK_SET) – this moves the pointer 5 positions ahead starting from the 
beginning of the file 
• lseek(fd,5,SEEK_CUR) – this moves the pointer 5 positions ahead from the current 
position in the file 
• lseek(fd,-5,SEEK_CUR) – this moves the pointer 5 positions back from the current 
position in the file 
V Semester 
Page 3 
Operating System (Intergrated)Lab Manual- P21CS504 
• lseek(fd,-5,SEEK_END) -> this moves the pointer 5 positions back from the end of 
the file 
• On success, lseek() returns the position of the pointer within the file as measured in 
bytes from the beginning of the file. But, on failure, it returns -1. 
Program: 
//Let the contents of the file F1 be “1234567890abcdefghijxxxxxxxx”. This means we want 
the output to be “abcdefghij”. 
//Note: the first character ‘1’ is at 0th position 
#include<unistd.h> 
#include<fcntl.h> 
#include<sys/types.h> 
#include<sys/stat.h> 
#include<stdio.h> 
int main() 
{ 
int n,f,f1; 
char buff[10]; 
f=open("seeking",O_RDWR); 
f1=lseek(f,10,SEEK_SET); 
printf("Pointer is at %d position\n",f1); 
read(f,buff,10); 
write(1,buff,10); 
} 
V Semester 
Page 4 
Operating System (Intergrated)Lab Manual- P21CS504 
 
V Semester Page 5 
 
Program 3: 
Write a program to implement IPC using shared memory. 

 
Shared Memory for Writer Process 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<sys/shm.h> 
#include<string.h> 
 
int main() 
{ 
int i; 
void *shared_memory; 
char buff[100]; 
int shmid; 
shmid=shmget((key_t)2345, 1024, 0666|IPC_CREAT);  
//creates shared memory segment with key 2345, having size 1024 bytes. IPC_CREAT 
//is used to create the shared segment if it does not exist. 0666 are the permisions on the 
//shared segment. 
printf("Key of shared memory is %d\n",shmid); 
shared_memory=shmat(shmid,NULL,0);  //process attached to shared memory segment 
printf("Process attached at %p\n",shared_memory);  
                     //this prints the address where th segment is attached with this process 
printf("Enter some data to write to shared memory\n"); 
read(0,buff,100); //get some input from user 
strcpy(shared_memory,buff); //data written to shared memory 
printf("You wrote : %s\n",(char *)shared_memory); 
} 
 

Output: 
Key of shared memory is 0 
Process attached at x7ffe04fb000 
Enter some data to write to shared memory 
Hello World 
You wrote: Hello World 
Shared Memory for Reader Process 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<sys/shm.h> 
#include<string.h> 
int main() 
{ 
int i; 
void *shared_memory; 
char buff[100]; 
int shmid; 
shmid=shmget((key_t)2345, 1024, 0666); 
printf("Key of shared memory is %d\n",shmid); 
shared_memory=shmat(shmid,NULL,0); //process attached to shared memory segment 
printf("Process attached at %p\n",shared_memory); 
printf("Data read from shared memory is : %s\n",(char *)shared_memory); 
} 

Output 
Key of Shared memory is 0 
Process attached at 0x7f76b4292999 
Data read from shared memory is: Hello World 
V Semester 
Page 8 





Program 4: 
 
Implement the Producer & consumer Problem (Semaphore) 
 
Description: 
Producer consumer problem is a synchronization problem. There is a fixed size buffer where 
producer produces items and that is consumed by the consumer process. One solution to the 
producer-consumer problem uses shared memory. To allow producer and consumer processes 
to run concurrently, there must be available a buffer of items that can be filled by the 
producer and emptied by the consumer. This buffer will reside in a region of memory that is 
shared by the producer and consumer processes. The producer and consumer must be 
synchronized, so that the consumer does not try to consume an item that has not yet been 
produced. 
 
#include<stdio.h>  
void main()  
{ 
 int buffer[10], bufsize, in, out, produce, consume, choice=0;  
in = 0;  
out = 0;  
bufsize = 10;  
while(choice !=3)  
    {  
      printf("\n 1. Produce \t 2. Consume \t3. Exit "); 
      printf("\n Enter your choice: ");  
      scanf("%d", &choice);  
      switch(choice)  
            {  
            case 1:  
                  if((in+1)%bufsize==out)  
                       printf("\n Buffer is Full"); 
 
 
                  else 
                        {  
                         printf("\n Enter the value: ");  
                         scanf("%d", &produce);  
                         buffer[in] = produce; 
                         in = (in+1)%bufsize;  
                        } 
                    break;  
           case 2:  
                if(in == out) 
                     printf("\n Buffer is Empty"); 
                else 
                    {  
                    consume = buffer[out];  
                    printf("\n The consumed value is %d", consume);  
                    out = (out+1)%bufsize; 
                    }  
                     break;  
                    } 
              } 
  } 
 
 
 
 
 
 
 
 
 
Program 5: 
Implement the solution to dining philosopher’s problem using monitors. 

ALGORITHM: 
Step 1: Start the program. 
Step 2: Define the number of philosophers. 
Step 3: Declare one thread per philosopher. 
Step 4: Declare one chop sticks per philosopher. 
Step 5: When a philosopher is hungry. 
i. See if chopsticks on both sides are free. 
ii. Acquire both chopsticks or. 
iii. Eat. 
iv. restore the chopsticks. 
v. If chopsticks aren’t free. 
 
 
Step 6: Wait till they are available. 
Step 7: Stop the program. 
 
PROGRAM: 
#include<stdio.h> 
#include<stdlib.h> 
int one(); 
int two() ; 
int tph, philname[20], status[20], howhung, hu[20], cho;  
int main()  
{  
    int i;  
    printf("\n\nDINING PHILOSOPHER PROBLEM");  
    printf("\nEnter the total no. of philosophers: ");  
    scanf("%d",&tph);  
    for(i=0;i<tph;i++) 
    {  
        philname[i] = (i+1); status[i]=1;  
     }  
    printf("How many are hungry : ");  
    scanf("%d", &howhung); 
    if(howhung==tph) 
    {  
        printf("\nAll are hungry..\nDead lock stage will occur");  
        printf("\nExiting.."); 
       }  
        else 
        {  
            for(i=0;i<howhung;i++) 
            { 
                printf("Enter philosopher %d position: ",(i+1));  
                scanf("%d", &hu[i]); status[hu[i]]=2;    
            }  

 
 
do{  
            printf("1.One can eat at a time\t2.Two can eat at a time\t3.Exit\nEnter your choice:");  
                scanf("%d", &cho); 
                switch(cho)  
                {  
                    case 1: 
                            one();  
                            break;  
                    case 2:  
                             two();  
                             break;  
                    case 3: 
                        exit(0);  
                    default:  
                        printf("\nInvalid option..");  
                } 
            } 
            while(1); 
            }  
    }  
 
int one() 
{ 
    int pos=0, x, i;  
    printf("\nAllow one philosopher to eat at any time\n");  
    for(i=0;i<howhung; i++, pos++)  
    { printf("\nP %d is granted to eat", philname[hu[pos]]);  
    for(x=pos;x<howhung;x++) 
    printf("\nP %d is waiting", philname[hu[x]]); 
    }  
}  
 

 
 
int two()  
{  
int i, j, s=0, t, r, x;  
printf("\n Allow two philosophers to eat at same time\n"); 
for(i=0;i<howhung;i++)  
{  
    for(j=i+1;j<howhung;j++) 
    { 
        if(abs(hu[i]-hu[j])>=1&& abs(hu[i]-hu[j])!=4) 
        {  
            printf("\n\ncombination %d \n", (s+1));  
            t=hu[i]; 
            r=hu[j]; 
            s++;  
            printf("\nP %d and P %d are granted to eat", philname[hu[i]], philname[hu[j]]); 
            for(x=0;x<howhung;x++) 
            {  
                if((hu[x]!=t)&&(hu[x]!=r)) 
                printf("\nP %d is waiting", philname[hu[x]]); 
                }  
            }  
        } 
       } 
    } 
 
 
 
 
 
 
 
 
Program 6: 
Implement the FCFS CPU Scheduling Algorithms 

#include<stdio.h>  
#include<conio.h>  
main()  
{ 
int bt[20], wt[20], tat[20], i, n; 
float wtavg, tatavg;  
clrscr();  
printf("\nEnter the number of processes -- "); 
scanf("%d", &n);  
for(i=0;i<n;i++)  
{  
printf("\nEnter Burst Time for Process %d -- ", i);  
scanf("%d", &bt[i]);  
}  
wt[0] = wtavg = 0;  
tat[0] = tatavg = bt[0]; 
for(i=1;i<n;i++) 
{ 
wt[i] = wt[i-1] +bt[i-1]; 
tat[i] = tat[i-1] +bt[i];  
wtavg = wtavg + wt[i];  
tatavg = tatavg + tat[i];  
}  
printf("\t PROCESS \tBURST TIME \t WAITING TIME\t TURNAROUND TIME\n");  
} 
for(i=0;i<n;i++) 
printf("\n\t P%d \t\t %d \t\t %d \t\t %d", i, bt[i], wt[i], tat[i]);  
printf("\nAverage Waiting Time -- %f", wtavg/n); 
printf("\nAverage Turnaround Time -- %f", tatavg/n);  
getch();  
} 





Program 7: 
Implement Bankers Algorithm for Deadlock Avoidance 
#include<stdio.h> 
#include<conio.h> 
int max[100][100]; 
int alloc[100][100]; 
int need[100][100]; 
int avail[100]; 
int n,r; 
void input(); 
void show(); 
void cal(); 
int main() 
{ 
int i,j; 
printf("********** Banker's Algorithm ************\n"); 
input(); 
V Semester 
Page 16 
Operating System (Intergrated)Lab Manual- P21CS504 
 
V Semester Page 17 
 
show(); 
cal(); 
getch(); 
return 0; 
} 
void input() 
 { 
int i,j; 
printf("Enter the no of Processes\t"); 
scanf("%d",&n); 
printf("Enter the no of resources instances\t"); 
scanf("%d",&r); 
printf("Enter the Max Matrix\n"); 
for(i=0;i<n;i++) 
    { 
        for(j=0;j<r;j++) 
        { 
        scanf("%d",&max[i][j]); 
        } 
    } 
printf("Enter the Allocation Matrix\n"); 
    for(i=0;i<n;i++) 
    { 
        for(j=0;j<r;j++) 
        { 
        scanf("%d",&alloc[i][j]); 
        } 
    } 
printf("Enter the available Resources\n"); 
for(j=0;j<r;j++) 
    { 
    scanf("%d",&avail[j]); 
    } 
} 
 
 
 
void show() 
 { 
 int i,j; 
 printf("Process\t Allocation\t Max\t Available\t"); 
    for(i=0;i<n;i++) 
        { 
        printf("\nP%d\t ",i+1); 
        for(j=0;j<r;j++) 
        { 
            printf("%d ",alloc[i][j]); 
        } 
        printf("\t\t"); 
        for(j=0;j<r;j++) 
        { 
        printf("%d ",max[i][j]); 
        } 
        printf("\t\t"); 
        if(i==0) 
        { 
        for(j=0;j<r;j++) 
        printf("%d ",avail[j]); 
        } 
        printf("\t\t"); 
        } 
        printf("\n"); 
} 
 
void cal() 
{ 
 int finish[100],temp,need[100][100],flag=1,k,c1=0; 
 int safe[100]; 
 int i,j; 
 for(i=0;i<n;i++) 
Operating System (Intergrated)Lab Manual- P21CS504 
 
V Semester Page 19 
 
    { 
    finish[i]=0; 
    } 
 //find need matrix 
 for(i=0;i<n;i++) 
    { 
    for(j=0;j<r;j++) 
        { 
        need[i][j]=max[i][j]-alloc[i][j]; 
        } 
    } 
printf("\n"); 
//print need matrix 
printf("----Need Matrix-------\n"); 
for(i=0;i<n;i++) 
    { 
    for(j=0;j<r;j++) 
        { 
        printf("%d   ",need[i][j]); 
        } 
        printf("\n"); 
    } 
    printf("\n"); 
while(flag) 
 { 
    flag=0; 
    for(i=0;i<n;i++) 
    { 
    int c=0; 
    for(j=0;j<r;j++) 
    { 
        if((finish[i]==0)&&(need[i][j]<=avail[j])) 
        { 
        c++; 
Operating System (Intergrated)Lab Manual- P21CS504 
 
V Semester Page 20 
 
        if(c==r) 
            { 
            for(k=0;k<r;k++) 
                { 
                avail[k]+=alloc[i][j]; 
                finish[i]=1; 
                flag=1; 
                } 
            printf("P%d->",i); 
            if(finish[i]==1) 
                { 
                    i=n; 
                } 
            } 
        } 
    } 
    } 
} 
printf("\n\n"); 
for(i=0;i<n;i++) 
    { 
        if(finish[i]==1) 
            { 
            c1++; 
            } 
        else 
            { 
            printf("P%d->",i); 
            } 
    } 
 if(c1==n) 
    { 
    printf("\n The system is in safe state"); 
    } 
Operating System (Intergrated)Lab Manual- P21CS504 
else 
{ 
printf("\n Process are in dead lock"); 
printf("\n System is in unsafe state"); 
} 
} 
V Semester 
Page 21 
Operating System (Intergrated)Lab Manual- P21CS504 
Program 8: 
Implement the following Memory Allocation Methods for fixed partition        
a) First Fit             
b) Worst Fit          
One of the simplest methods for memory allocation is to divide memory into several fixed
sized partitions. Each partition may contain exactly one process. In this multiple-partition 
method, when a partition is free, a process is selected from the input queue and is loaded 
into the free partition. When the process terminates, the partition becomes available for 
another process. The operating system keeps a table indicating which parts of memory are 
available and which are occupied. Finally, when a process arrives and needs memory, a 
memory section large enough for this process is provided. When it is time to load or swap a 
process into main memory, and if there is more than one free block of memory of sufficient 
size, then the operating system must decide which free block to allocate. Best-fit strategy 
chooses the block that is closest in size to the request. First-fit chooses the first available 
block that is large enough. Worst-fit chooses the largest available block. 
A. First Fit    
#include<stdio.h>  
#include<conio.h> 
#define max 25 
void main()  
{  
int frag[max],b[max],f[max],i,j,nb,nf,temp;  
static int bf[max],ff[max]; 
clrscr();  
printf("\n\tMemory Management Scheme - First Fit");  
printf("\nEnter the number of blocks:");  
scanf("%d",&nb);  
printf("Enter the number of files:");  
scanf("%d",&nf);  
printf("\nEnter the size of the blocks:-\n");  
for(i=1;i<=nb;i++)  
V Semester 
Page 22 
Operating System (Intergrated)Lab Manual- P21CS504 
{ 
printf("Block %d:",i); scanf("%d",&b[i]); 
} 
printf("Enter the size of the files :-\n"); 
for(i=1;i<=nf;i++)  
{  
printf("File %d:",i); 
scanf("%d",&f[i]);  
} 
for(i=1;i<=nf;i++) 
{  
for(j=1;j<=nb;j++) 
{ 
if(bf[j]!=1) 
{ 
temp=b[j]-f[i]; 
if(temp>=0)  
{  
ff[i]=j; 
break; 
} 
} 
}  
frag[i]=temp; 
bf[ff[i]]=1; 
} 
printf("\nFile_no:\tFile_size :\tBlock_no:\tBlock_size:\tFragement");  
for(i=1;i<=nf;i++) 
printf("\n%d\t\t%d\t\t%d\t\t%d\t\t%d",i,f[i],ff[i],b[ff[i]],frag[i]);  
getch(); 
} 
V Semester 
Page 23 
Operating System (Intergrated)Lab Manual- P21CS504 
B.   Worst Fit      
#include<stdio.h>  
#include<conio.h>  
#define max 25  
void main()  
{  
int frag[max],b[max],f[max],i,j,nb,nf,temp,highest=0;  
static int bf[max],ff[max];  
clrscr(); 
printf("\n\tMemory Management Scheme - Worst Fit");  
printf("\nEnter the number of blocks:"); 
scanf("%d",&nb);  
printf("Enter the number of files:");  
scanf("%d",&nf);  
printf("\nEnter the size of the blocks:-\n");  
for(i=1;i<=nb;i++)  
{ 
printf("Block %d:",i); 
scanf("%d",&b[i]);  
}  
V Semester 
Page 24 
Operating System (Intergrated)Lab Manual- P21CS504 
printf("Enter the size of the files :-\n");  
for(i=1;i<=nf;i++)  
{  
printf("File %d:",i); 
scanf("%d",&f[i]); 
}  
for(i=1;i<=nf;i++)  
{  
for(j=1;j<=nb;j++)  
{  
if(bf[j]!=1) //if bf[j] is not allocated  
{  
temp=b[j]-f[i];  
if(temp>=0) 
if(highest<temp)  
{ 
ff[i]=j;  
highest=temp; 
}  
} 
}  
frag[i]=highest; 
bf[ff[i]]=1;  
highest=0;  
}  
printf("\nFile_no:\tFile_size :\tBlock_no:\tBlock_size:\tFragement"); 
for(i=1;i<=nf;i++)  
printf("\n%d\t\t%d\t\t%d\t\t%d\t\t%d",i,f[i],ff[i],b[ff[i]],frag[i]);  
getch(); 
}      
V Semester 
Page 25 
Operating System (Intergrated)Lab Manual- P21CS504 
V Semester 
Page 26 
Operating System (Intergrated)Lab Manual- P21CS504 
Program 9: 
Implement the following Page Replacement Algorithms  
a) FIFO           
b) LRU            
DESCRIPTION : 
Page replacement is basic to demand paging. It completes the separation between logical 
memory and physical memory. With this mechanism, an enormous virtual memory can be 
provided for programmers on a smaller physical memory. There are many different page
replacement algorithms. Every operating system probably has its own replacement scheme. 
A FIFO replacement algorithm associates with each page the time when that page was 
brought into memory. When a page must be replaced, the oldest page is chosen. If the recent 
past is used as an approximation of the near future, then the page that has not been used for 
the longest period of time can be replaced. This approach is the Least Recently Used (LRU) 
algorithm. LRU replacement associates with each page the time of that page's last use. When 
a page must be replaced, LRU chooses the page that has not been used for the longest period 
of time. Least frequently used (LFU) page-replacement algorithm requires that the page with 
the smallest count be replaced. The reason for this selection is that an actively used page 
should have a large reference count. 
A. FIFO     
#include<stdio.h> 
#include<conio.h>  
main()  
{ 
int i, j, k, f, pf=0, count=0, rs[25], m[10], n;  
clrscr(); 
printf("\n Enter the length of reference string -- ");  
scanf("%d",&n); printf("\n Enter the reference string -- ");  
for(i=0;i<n;i++)  
scanf("%d",&rs[i]);  
printf("\n Enter no. of frames -- ");  
scanf("%d",&f); 
for(i=0;i<f;i++)  
V Semester 
Page 27 
Operating System (Intergrated)Lab Manual- P21CS504 
m[i]=-1;  
printf("\n The Page Replacement Process is -- \n");  
for(i=0;i<n;i++)  
{  
for(k=0;k<f;k++)  
{ 
if(m[k]==rs[i]) break; 
} 
if(k==f)  
{  
m[count++]=rs[i]; 
pf++;  
} 
for(j=0;j<f;j++) 
printf("\t%d",m[j]); 
if(k==f)  
printf("\tPF No. %d",pf); printf("\n"); 
if(count==f)  
count=0;  
}  
printf("\n The number of Page Faults using FIFO are %d",pf); 
getch();  
} 
V Semester 
Page 28 
Operating System (Intergrated)Lab Manual- P21CS504 
B. LRU       
#include<stdio.h>  
#include<conio.h>  
main()  
{  
int i, j , k, min, rs[25], m[10], count[10], flag[25], n, f, pf=0, next=1;  
clrscr();  
printf("Enter the length of reference string -- ");  
scanf("%d",&n); printf("Enter the reference string -- "); 
for(i=0;i<n;i++) 
{  
scanf("%d",&rs[i]);  
flag[i]=0; 
} 
printf("Enter the number of frames -- ");  
scanf("%d",&f);  
for(i=0;i<f;i++)  
{  
count[i]=0;  
m[i]=-1;  
} 
printf("\nThe Page Replacement process is -- \n"); 
for(i=0;i<n;i++)  
{  
for(j=0;j<f;j++) 
{ 
if(m[j]==rs[i])  
{ 
flag[i]=1;  
count[j]=next; next++;  
}  
} 
V Semester 
Page 29 
Operating System (Intergrated)Lab Manual- P21CS504 
if(flag[i]==0)  
{  
if(i<f) 
else 
{ 
m[i]=rs[i]; 
count[i]=next;  
next++;  
}  
{  
min=0;  
for(j=1;j<f;j++) 
if(count[min] > count[j]) 
min=j;  
m[min]=rs[i];  
count[min]=next; 
next++; 
}  
pf++;  
}  
for(j=0;j<f;j++)  
printf("%d\t", m[j]); 
if(flag[i]==0) 
printf("PF No. -- %d" , pf);  
printf("\n");  
}  
printf("\nThe number of page faults using LRU are %d",pf);  
getch(); 
} 
V Semester 
Page 30 
Operating System (Intergrated)Lab Manual- P21CS504 
V Semester 
Page 31 
Operating System (Intergrated)Lab Manual- P21CS504 
Program 10 
Implement the following Disk Scheduling Algorithms: 
a) SSTF Scheduling    b) SCAN Scheduling   
A. SSTF Scheduling     
SSTF stands for Shortest Time First which very uses full of learning about how the disk drive 
manages the data having the shortest seek time. 
Algorithm: 
1. Let Request array represents an array storing indexes of tracks that have been requested. 
‘head’ is the position of disk head. 
2. Find the positive distance of all tracks in the request array from head. 
3. Find a track from requested array which has not been accessed/serviced yet and has 
minimum distance from head. 
4. Increment the total seek count with this distance. 
5. Currently serviced track position now becomes the new head position. 
6. Go to step 2 until all tracks in request array have not been serviced. 
#include<stdio.h> 
#include<conio.h> 
#include<math.h> 
int main() 
{ 
int queue[100],t[100],head,seek=0,n,i,j,temp; 
float avg; 
// clrscr(); 
printf("*** SSTF Disk Scheduling Algorithm ***\n"); 
printf("Enter the size of Queue\t"); 
scanf("%d",&n); 
printf("Enter the Queue\t"); 
for(i=0;i<n;i++) 
{ 
scanf("%d",&queue[i]); 
V Semester 
Page 32 
Operating System (Intergrated)Lab Manual- P21CS504 
} 
printf("Enter the initial head position\t"); 
scanf("%d",&head); 
for(i=1;i<n;i++) 
t[i]=abs(head-queue[i]); 
for(i=0;i<n;i++) 
{ 
for(j=i+1;j<n;j++) 
{ 
if(t[i]>t[j]) 
{ 
temp=t[i]; 
t[i]=t[j]; 
t[j]=temp; 
temp=queue[i]; 
queue[i]=queue[j]; 
queue[j]=temp; 
} 
} 
} 
for(i=1;i<n-1;i++) 
{ 
seek=seek+abs(head-queue[i]); 
head=queue[i]; 
} 
printf("\nTotal Seek Time is%d\t",seek); 
avg=seek/(float)n; 
printf("\nAverage Seek Time is %f\t",avg); 
return 0; 
} 
OUTPUT: 
*** SSTF Disk Scheduling Algorithm *** 
Enter the size of Queue 5 
V Semester 
Page 33 
Operating System (Intergrated)Lab Manual- P21CS504 
Enter the Queue 10 17 2 15 4 
Enter the initial head position 3 
Total Seek Time is14 
Average Seek Time is 2.800000 
RESULT: 
Thus the program was executed and verified successfully. 
B. SCAN Scheduling   
SCAN DISK SCHEDULING ALGORITHM  
#include<stdio.h>  
main()  
{ 
int t[20], d[20], h, i, j, n, temp, k, atr[20], tot, p, sum=0;  
clrscr(); 
printf("enter the no of tracks to be traveresed");  
scanf("%d'",&n); 
printf("enter the position of head"); 
scanf("%d",&h);  
t[0]=0;t[1]=h;  
printf("enter the tracks");  
for(i=2;i<n+2;i++)  
scanf("%d",&t[i]); 
for(i=0;i<n+2;i++) 
{  
for(j=0;j<(n+2)-i-1;j++)  
{ 
if(t[j]>t[j+1]) 
{  
temp=t[j];  
t[j]=t[j+1];  
t[j+1]=temp; 
} 
} 
V Semester 
Page 34 
Operating System (Intergrated)Lab Manual- P21CS504 
}  
for(i=0;i<n+2;i++) 
if(t[i]==h) 
j=i; 
k=i; 
p=0;  
while(t[j]!=0)  
{  
atr[p]=t[j]; 
j--;  
p++;  
}  
atr[p]=t[j]; 
for(p=k+1;p<n+2;p++,k++)  
atr[p]=t[k+1]; 
for(j=0;j<n+1;j++) 
{  
if(atr[j]>atr[j+1])  
d[j]=atr[j]-atr[j+1]; 
else  
d[j]=atr[j+1]-atr[j];  
sum+=d[j]; 
}  
printf("\nAverage header movements:%f",(float)sum/n);  
getch(); 
}  
V Semester 
Page 35 
Operating System (Intergrated)Lab Manual- P21CS504 
INPUT 
Enter no.of tracks:9  
Enter track position:55 58 60 70 18 90 150 160 184  
OUTPUT: 
Tracks Traversed  
150               
160    
184    
90    
70    
60    
58    
55    
18    
Difference Between tracks 
50 
10 
24 
94 
20 
10 
2 
3 
37 
V Semester 
Page 36 
Operating System (Intergrated)Lab Manual- P21CS504 
Program 11: 
Implement the following File Allocation Strategies 
a) Sequential   b) Indexed    
OBJECTIVE Write a C program to simulate the following file allocation strategies. 
a) Sequential b) Indexed 
DESCRIPTION A file is a collection of data, usually stored on disk. As a logical entity, a 
file enables to divide data into meaningful groups. As a physical entity, a file should be 
considered in terms of its organization. The term "file organization" refers to the way in 
which data is stored in a file and, consequently, the method(s) by which it can be accessed.  
SEQUENTIAL FILE ALLOCATION In this file organization, the records of the file are 
stored one after another both physically and logically. That is, record with sequence number 
16 is located just after the 15th record. A record of a sequential file can only be accessed by 
reading all the previous records. 
INDEXED FILE ALLOCATION Indexed file allocation strategy brings all the pointers 
together into one location: an index block. Each file has its own index block, which is an 
array of disk-block addresses. The ith entry in the index block points to the ith block of the 
file. The directory contains the address of the index block. To find and read the ith block, the 
pointer in the ith index-block entry is used. 
A. SEQUENTIAL FILE ALLOCATION 
#include<stdio.h> 
#include<conio.h> 
struct fileTable 
{  
char name[20];  
int sb, nob; 
}ft[30];  
V Semester 
Page 37 
Operating System (Intergrated)Lab Manual- P21CS504 
void main()  
{  
int i, j, n;  
char s[20];  
clrscr();  
printf("Enter no of files :");  
scanf("%d",&n);  
for(i=0;i<n;i++) 
{  
printf("\nEnter file name %d :",i+1);  
scanf("%s",ft[i].name);  
printf("Enter starting block of file %d :",i+1);  
scanf("%d",&ft[i].sb);  
printf("Enter no of blocks in file %d :",i+1);  
scanf("%d",&ft[i].nob);  
}  
printf("\nEnter the file name to be searched -- ");  
scanf("%s",s);  
for(i=0;i<n;i++)  
if(strcmp(s, ft[i].name)==0) 
break;  
if(i==n)  
printf("\nFile Not Found");  
else  
{  
printf("\nFILE NAME START BLOCK NO OF BLOCKS BLOCKS OCCUPIED\n");  
printf("\n%s\t\t%d\t\t%d\t",ft[i].name,ft[i].sb,ft[i].nob);  
for(j=0;j<ft[i].nob;j++) 
printf("%d, ",ft[i].sb+j); 
}  
getch(); 
}  
V Semester 
Page 38 
Operating System (Intergrated)Lab Manual- P21CS504 
INPUT: Enter no of files :3 
Enter file name 1 :A  
Enter starting block of file 1 :85  
Enter no of blocks in file 1 :6  
Enter file name 2 :B  
Enter starting block of file 2 :102 
Enter no of blocks in file 2 :4  
Enter file name 3 :C  
Enter starting block of file 3 :60  
Enter no of blocks in file 3 :4  
Enter the file name to be searched -- B  
OUTPUT:  
FILE NAME     START BLOCK    NO OF BLOCKS        BLOCKS OCCUPIED 
B                           
102                              
4                                  
102, 103, 104, 105 
V Semester 
Page 39 
Operating System (Intergrated)Lab Manual- P21CS504 
B. INDEXED FILE ALLOCATION 
#include<stdio.h>  
#include<conio.h>  
struct fileTable  
{  
char name[20]; 
int nob, blocks[30]; 
}ft[30];  
void main()  
{  
int i, j, n;  
char s[20]; 
clrscr();  
printf("Enter no of files :"); 
scanf("%d",&n); 
for(i=0;i<n;i++) 
{  
printf("\nEnter file name %d :",i+1);  
scanf("%s",ft[i].name); 
printf("Enter no of blocks in file %d :",i+1);  
scanf("%d",&ft[i].nob);  
printf("Enter the blocks of the file :");  
for(j=0;j<ft[i].nob;j++)  
scanf("%d",&ft[i].blocks[j]); 
}  
printf("\nEnter the file name to be searched -- ");  
scanf("%s",s);  
for(i=0;i<n;i++)  
if(strcmp(s, ft[i].name)==0)  
break;  
if(i==n)  
printf("\nFile Not Found");  
else  
{  
V Semester 
Page 40 
Operating System (Intergrated)Lab Manual- P21CS504 
printf("\nFILE NAME NO OF BLOCKS BLOCKS OCCUPIED");  
printf("\n %s\t\t%d\t",ft[i].name,ft[i].nob);  
for(j=0;j<ft[i].nob;j++) 
printf("%d, ",ft[i].blocks[j]);  
}  
getch(); 
} 
INPUT:  
Enter no of files : 2  
Enter file 1 : A  
Enter no of blocks in file 1 : 4  
Enter the blocks of the file 1 : 12 23 9 4  
Enter file 2 : G  
Enter no of blocks in file 2: 5  
Enter the blocks of the file 2: 88 77 66 55 44 
Enter the file to be searched: G  
OUTPUT:  
FILE NAME       NO OF BLOCKS                        
G                        
5                                                   
BLOCKS OCCUPIED    
88, 77, 66, 55, 44 13 
V Semester 
Page 41 
