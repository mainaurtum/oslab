Program 1: 

#include<unistd.h> 
int main() 
{ 
int nread; 
char buff[20]; 
nread=read(0,buff,10);//read 10 bytes from standard input device(keyboard) and store it  
in buffer(buff) 
write (1,buff,nread);//print 10 bytes from the buffer on the screen 
} 


b. Write a program to print 10 characters starting from the 10th character 
from a file(lseek() system call) 

#include<unistd.h> 
#include<fcntl.h> 
#include<sys/types.h 
#include<sys/stat.h> 
#include<stdio.h> 
int main() 
{ 
int n,f,f1; 
char buff[10]; 
f=open("seeking",O_RDWR); 
f1=lseek(f,10,SEEK_SET); 
printf("Pointer is at %d position\n",f1); 
read(f,buff,10); 
write(1,buff,10); 
} 





Program 2: 
 
Shared Memory for Writer Process 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<sys/shm.h> 
#include<string.h> 
int main() 
{ 
int i; 
void *shared_memory; 
char buff[100]; 
int shmid; 
shmid=shmget((key_t)2345, 1024, 0666|IPC_CREAT);  
//creates shared memory segment with key 2345, having size 1024 bytes. IPC_CREAT 
is used to create the shared segment if it does not exist. 0666 are the permisions on the shared 
segment. 
printf("Key of shared memory is %d\n",shmid); 
shared_memory=shmat(shmid,NULL,0);  //process attached to shared memory segment 
printf("Process attached at %p\n",shared_memory);  
//this prints the address where th segment is attached with this process 
printf("Enter some data to write to shared memory\n"); 
read(0,buff,100); //get some input from user 
strcpy(shared_memory,buff); //data written to shared memory 
printf("You wrote : %s\n",(char *)shared_memory); 
} 


Output: 
Key of shared memory is 0 
Process attached at x7ffe04fb000 
Enter some data to write to shared memory 
Hello World 
You wrote: Hello World 


Shared Memory for Reader Process 
#include<stdio.h> 
#include<stdlib.h> 
#include<unistd.h> 
#include<sys/shm.h> 
#include<string.h> 
int main() 
{ 
int i; 
void *shared_memory; 
char buff[100]; 
int shmid; 
shmid=shmget((key_t)2345, 1024, 0666); 
printf("Key of shared memory is %d\n",shmid); 
shared_memory=shmat(shmid,NULL,0); //process attached to shared memory segment 
printf("Process attached at %p\n",shared_memory); 
printf("Data read from shared memory is : %s\n",(char *)shared_memory); 
} 

Output 
Key of Shared memory is 0 
Process attached at 0x7f76b4292999 
Data read from shared memory is: Hello World 



Program 3: 
Implement the Producer & consumer Problem (Semaphore) 

#include<stdio.h>  
void main()  
{ 
int buffer[10], bufsize, in, out, produce, consume, choice=0;  
in = 0;  
out = 0;  
bufsize = 10;  
while(choice !=3)  
{  
printf("\n 1. Produce \t 2. Consume \t3. Exit "); 
printf("\n Enter your choice: ");  
scanf("%d", &choice);  
switch(choice)  
{  
case 1:  
if((in+1)%bufsize==out)  
printf("\n Buffer is Full"); 
else 
 
 
                        {  
                         printf("\n Enter the value: ");  
                         scanf("%d", &produce);  
                         buffer[in] = produce; 
                         in = (in+1)%bufsize;  
                        } 
                    break;  
           case 2:  
                if(in == out) 
                     printf("\n Buffer is Empty"); 
                else 
                    {  
                    consume = buffer[out];  
                    printf("\n The consumed value is %d", consume);  
                    out = (out+1)%bufsize; 
                    }  
                     break;  
                    } 
              } 
  } 
 
 
 
 
 
 
 
 
 
Program 4: 
Implement the solution to dining philosopher’s problem using monitors. 
PROGRAM: 
Operating System Lab Manual  
#include<stdio.h> 
#include<stdlib.h> 
int one(); 
int two() ; 
int tph, philname[20], status[20], howhung, hu[20], cho;  
int main()  
{  
int i;  
printf("\n\nDINING PHILOSOPHER PROBLEM");  
printf("\nEnter the total no. of philosophers: ");  
scanf("%d",&tph);  
for(i=0;i<tph;i++) 
{  
philname[i] = (i+1); status[i]=1;  
}  
printf("How many are hungry : ");  
scanf("%d", &howhung); 
if(howhung==tph) 
{  
printf("\nAll are hungry..\nDead lock stage will occur");  
printf("\nExiting.."); 
}  
else 
{  
for(i=0;i<howhung;i++) 
{ 
printf("Enter philosopher %d position: ",(i+1));  
scanf("%d", &hu[i]); status[hu[i]]=2;  
}  
 
 
            do  
            {  
                printf("1.One can eat at a time\t2.Two can eat at a time\t3.Exit\nEnter your choice:");  
                scanf("%d", &cho); 
                switch(cho)  
                {  
                    case 1: 
                            one();  
                            break;  
                    case 2:  
                             two();  
                             break;  
                    case 3: 
                        exit(0);  
                    default:  
                        printf("\nInvalid option..");  
                } 
            } 
            while(1); 
            }  
     
}  
 
int one() 
{ 
    int pos=0, x, i;  
    printf("\nAllow one philosopher to eat at any time\n");  
    for(i=0;i<howhung; i++, pos++)  
    { printf("\nP %d is granted to eat", philname[hu[pos]]);  
    for(x=pos;x<howhung;x++) 
    printf("\nP %d is waiting", philname[hu[x]]); 
    }  
}  
 
int two()  
{  
int i, j, s=0, t, r, x;  
printf("\n Allow two philosophers to eat at same time\n"); 
for(i=0;i<howhung;i++)  
{  
for(j=i+1;j<howhung;j++) 
{ 
if(abs(hu[i]-hu[j])>=1&& abs(hu[i]-hu[j])!=4) 
{  
printf("\n\ncombination %d \n", (s+1));  
t=hu[i]; 
r=hu[j]; 
s++;  
printf("\nP %d and P %d are granted to eat", philname[hu[i]], philname[hu[j]]); 
for(x=0;x<howhung;x++) 
{  
}  
} 
} 
} 
if((hu[x]!=t)&&(hu[x]!=r)) 
printf("\nP %d is waiting", philname[hu[x]]); 
}  




Program 5: 
Implement the various CPU Scheduling Algorithms (FCFS, RR) 
FCFS: 
#include<stdio.h>  
#include<conio.h>  
main()  
{ 
int bt[20], wt[20], tat[20], i, n; 
float wtavg, tatavg;  
clrscr();  
printf("\nEnter the number of processes -- "); 
scanf("%d", &n);  
for(i=0;i<n;i++)  
{  
printf("\nEnter Burst Time for Process %d -- ", i);  
scanf("%d", &bt[i]);  
}  
wt[0] = wtavg = 0;  
tat[0] = tatavg = bt[0]; 
for(i=1;i<n;i++) 
{ 
wt[i] = wt[i-1] +bt[i-1]; 
tat[i] = tat[i-1] +bt[i];  
wtavg = wtavg + wt[i];  
tatavg = tatavg + tat[i];  
}  
printf("\t PROCESS \tBURST TIME \t WAITING TIME\t TURNAROUND TIME\n");  
} 
for(i=0;i<n;i++) 
printf("\n\t P%d \t\t %d \t\t %d \t\t %d", i, bt[i], wt[i], tat[i]);  
printf("\nAverage Waiting Time -- %f", wtavg/n); 
printf("\nAverage Turnaround Time -- %f", tatavg/n);  
getch(); } 



Program 6: 
Round Robin: 
#include<stdio.h>  
main()  
{  
int i,j,n,bu[10],wa[10],tat[10],t,ct[10],max;  
float awt=0,att=0,temp=0; 
clrscr();  
printf("Enter the no of processes -- ");  
scanf("%d",&n);  
for(i=0;i<n;i++)  
{  
printf("\nEnter Burst Time for process %d -- ", i+1); 
scanf("%d",&bu[i]);  
ct[i]=bu[i];  
} 
printf("\nEnter the size of time slice -- ");  
scanf("%d",&t);  
max=bu[0];  
for(i=1;i<n;i++) 
if(max<bu[i])  
max=bu[i];  
for(j=0;j<(max/t)+1;j++)  
for(i=0;i<n;i++)  
if(bu[i]!=0) 
if(bu[i]<=t)  
{ 
tat[i]=temp+bu[i]; 
temp=temp+bu[i];  
bu[i]=0; 
} 
else 
{  
bu[i]=bu[i]-t; 
temp=temp+t;  
} 
Operating System Lab Manual  
for(i=0;i<n;i++)  
{  
wa[i]=tat[i]-ct[i]; 
att+=tat[i];  
awt+=wa[i];  
}  
printf("\nThe Average Turnaround time is -- %f",att/n);  
printf("\nThe Average Waiting time is -- %f ",awt/n);  
printf("\n\tPROCESS\t BURST TIME \t WAITING TIME\t TURN AROUND TIME\n");  
for(i=0;i<n;i++) 
printf("\t%d \t %d \t\t %d \t\t %d \n",i+1,ct[i],wa[i],tat[i]);  
getch();  
} 





Program 7: 
Implement Bankers Algorithm for Deadlock Avoidance 

#include<stdio.h>  
struct file 
{ 
int all[10]; 
int max[10]; 
int need[10]; 
int flag;  
}; 
void main()  
{  
struct file f[10];  
int fl; 
int i, j, k, p, b, n, r, g, cnt=0, id, newr;  
int avail[10],seq[10];  
clrscr();  
printf("Enter number of processes -- "); 
scanf("%d",&n);  
printf("Enter number of resources -- ");  
scanf("%d",&r);  
for(i=0;i<n;i++)  
{  
printf("Enter details for P%d",i); 
printf("\nEnter allocation\t -- \t");  
for(j=0;j<r;j++)  
scanf("%d",&f[i].all[j]);  
printf("Enter Max\t\t -- \t");  
for(j=0;j<r;j++)  
scanf("%d",&f[i].max[j]); 
f[i].flag=0; 
}  
printf("\nEnter Available Resources\t -- \t"); 
for(i=0;i<r;i++) 
scanf("%d",&avail[i]);  
printf("\nEnter New Request Details -- ");  
printf("\nEnter pid \t -- \t");  
scanf("%d",&id);  
printf("Enter Request for Resources \t -- \t");  
for(i=0;i<r;i++)  
{  
scanf("%d",&newr);  
f[id].all[i] += newr; 
avail[i]=avail[i] - newr; 
}  
for(i=0;i<n;i++) 
{ 
for(j=0;j<r;j++)  
{ 
f[i].need[j]=f[i].max[j]-f[i].all[j];  
if(f[i].need[j]<0) 
f[i].need[j]=0; 
} 
}  
Operating System Lab Manual  
cnt=0; 
fl=0; 
while(cnt!=n)  
{  
g=0;  
for(j=0;j<n;j++) 
{  
if(f[j].flag==0) 
{  
b=0;  
for(p=0;p<r;p++) 
{  
if(avail[p]>=f[j].need[p]) 
b=b+1; else b=b-1; 
}  
if(b==r) 
{ 
printf("\nP%d is visited",j); 
seq[fl++]=j; 
f[j].flag=1;  
for(k=0;k<r;k++)  
avail[k]=avail[k]+f[j].all[k]; 
cnt=cnt+1;  
printf("(");  
for(k=0;k<r;k++)  
printf("%3d",avail[k]);  
printf(")"); g=1; 
} 
}  
} 
if(g==0)  
{ 
printf("\n REQUEST NOT GRANTED -- DEADLOCK OCCURRED"); 
printf("\n SYSTEM IS IN UNSAFE STATE"); 
goto y;  
} 
}  
printf("\nSYSTEM IS IN SAFE STATE");  
printf("\nThe Safe Sequence is -- (");  
for(i=0;i<fl;i++) 
printf("P%d ",seq[i]); printf(")"); 
y: printf("\nProcess\t\tAllocation\t\tMax\t\t\tNeed\n");  
for(i=0;i<n;i++)  
{ 
printf("P%d\t",i); 
for(j=0;j<r;j++)  
printf("%6d",f[i].all[j]);  
for(j=0;j<r;j++)  
printf("%6d",f[i].max[j]); 
for(j=0;j<r;j++)  
printf("%6d",f[i].need[j]); printf("\n"); } 
getch();  
} 





Program 8: 
Implement the following Memory Allocation Methods for fixed partition        
a) First Fit
             b) Worst Fit          

a) Worst Fit      
#include<stdio.h>  
#include<conio.h>  
#define max 25  
void main()  
{  
int frag[max],b[max],f[max],i,j,nb,nf,temp,highest=0;  
static int bf[max],ff[max];  
clrscr(); 
printf("\n\tMemory Management Scheme - Worst Fit");  
printf("\nEnter the number of blocks:"); 
scanf("%d",&nb);  
printf("Enter the number of files:");  
scanf("%d",&nf);  
printf("\nEnter the size of the blocks:-\n");  
for(i=1;i<=nb;i++)  
{ 
printf("Block %d:",i); 
scanf("%d",&b[i]);  
}  
printf("Enter the size of the files :-\n");  
for(i=1;i<=nf;i++)  
{  
printf("File %d:",i); 
scanf("%d",&f[i]); 
}  
for(i=1;i<=nf;i++)  
{  
Operating System Lab Manual  
for(j=1;j<=nb;j++)  
{  
if(bf[j]!=1) //if bf[j] is not allocated  
{  
temp=b[j]-f[i];  
if(temp>=0) 
if(highest<temp)  
{ 
ff[i]=j;  
highest=temp; 
}  
} 
}  
frag[i]=highest; 
bf[ff[i]]=1;  
highest=0;  
}  
printf("\nFile_no:\tFile_size :\tBlock_no:\tBlock_size:\tFragement"); 
for(i=1;i<=nf;i++)  
printf("\n%d\t\t%d\t\t%d\t\t%d\t\t%d",i,f[i],ff[i],b[ff[i]],frag[i]);  
getch(); 
}      





b) First Fit    
Program 9: 
#include<stdio.h>  
#include<conio.h> 
#define max 25 
void main()  
{  
int frag[max],b[max],f[max],i,j,nb,nf,temp;  
static int bf[max],ff[max]; 
clrscr();  
printf("\n\tMemory Management Scheme - First Fit");  
printf("\nEnter the number of blocks:");  
scanf("%d",&nb);  
printf("Enter the number of files:");  
scanf("%d",&nf);  
printf("\nEnter the size of the blocks:-\n");  
for(i=1;i<=nb;i++)  
{ 
printf("Block %d:",i); scanf("%d",&b[i]); 
} 
Operating System Lab Manual  
printf("Enter the size of the files :-\n"); 
for(i=1;i<=nf;i++)  
{  
printf("File %d:",i); 
scanf("%d",&f[i]);  
} 
for(i=1;i<=nf;i++) 
{  
for(j=1;j<=nb;j++) 
{ 
if(bf[j]!=1) 
{ 
temp=b[j]-f[i]; 
if(temp>=0)  
{  
ff[i]=j; 
break; 
} 
} 
}  
frag[i]=temp; 
bf[ff[i]]=1; 
} 
printf("\nFile_no:\tFile_size :\tBlock_no:\tBlock_size:\tFragement");  
for(i=1;i<=nf;i++) 
printf("\n%d\t\t%d\t\t%d\t\t%d\t\t%d",i,f[i],ff[i],b[ff[i]],frag[i]);  
getch(); 
} 





Program 10: 
Implement the following Page Replacement Algorithms  
a) FIFO
           b) LRU            
DESCRIPTION : 
Page replacement is basic to demand paging. It completes the separation between logical 
memory and physical memory. With this mechanism, an enormous virtual memory can be 
provided for programmers on a smaller physical memory. There are many different page
replacement algorithms. Every operating system probably has its own replacement scheme. A 
FIFO replacement algorithm associates with each page the time when that page was brought 
into memory. When a page must be replaced, the oldest page is chosen. If the recent past is 
used as an approximation of the near future, then the page that has not been used for the longest 
period of time can be replaced. This approach is the Least Recently Used (LRU) algorithm. 
LRU replacement associates with each page the time of that page's last use. When a page must 
be replaced, LRU chooses the page that has not been used for the longest period of time. Least 
frequently used (LFU) page-replacement algorithm requires that the page with the smallest 
count be replaced. The reason for this selection is that an actively used page should have a 
large reference count. 
a) FIFO     
Operating System Lab Manual  
#include<stdio.h> 
#include<conio.h>  
main()  
{ 
int i, j, k, f, pf=0, count=0, rs[25], m[10], n;  
clrscr(); 
printf("\n Enter the length of reference string -- ");  
scanf("%d",&n); printf("\n Enter the reference string -- ");  
for(i=0;i<n;i++)  
scanf("%d",&rs[i]);  
printf("\n Enter no. of frames -- ");  
scanf("%d",&f); 
for(i=0;i<f;i++)  
m[i]=-1;  
printf("\n The Page Replacement Process is -- \n");  
for(i=0;i<n;i++)  
{  
for(k=0;k<f;k++)  
{ 
if(m[k]==rs[i]) break; 
} 
if(k==f)  
{  
m[count++]=rs[i]; 
pf++;  
} 
for(j=0;j<f;j++) 
printf("\t%d",m[j]); 
if(k==f)  
printf("\tPF No. %d",pf); printf("\n"); 
if(count==f)  
count=0;  
}  
Operating System Lab Manual  
printf("\n The number of Page Faults using FIFO are %d",pf); 
getch();  
} 
b) LRU       
c) Program 11: 
#include<stdio.h>  
#include<conio.h>  
main()  
{  
int i, j , k, min, rs[25], m[10], count[10], flag[25], n, f, pf=0, next=1;  
clrscr();  
printf("Enter the length of reference string -- ");  
scanf("%d",&n); printf("Enter the reference string -- "); 
for(i=0;i<n;i++) 
{  
Operating System Lab Manual  
 
 
scanf("%d",&rs[i]);  
flag[i]=0; 
 } 
 printf("Enter the number of frames -- ");  
scanf("%d",&f);  
for(i=0;i<f;i++)  
{  
count[i]=0;  
m[i]=-1;  
} 
 printf("\nThe Page Replacement process is -- \n"); 
 for(i=0;i<n;i++)  
{  
for(j=0;j<f;j++) 
 { 
    if(m[j]==rs[i])  
{ 
     flag[i]=1;  
count[j]=next; next++;  
}  
} 
    if(flag[i]==0)  
{  
if(i<f) 
 { 
 m[i]=rs[i]; 
      count[i]=next;  
next++;  
}  
else 
     {  
min=0;  
for(j=1;j<f;j++) 
      if(count[min] > count[j]) 
Operating System Lab Manual  
min=j;  
m[min]=rs[i];  
count[min]=next; 
next++; 
}  
pf++;  
}  
for(j=0;j<f;j++)  
printf("%d\t", m[j]); 
if(flag[i]==0) 
printf("PF No. -- %d" , pf);  
printf("\n");  
}  
printf("\nThe number of page faults using LRU are %d",pf);  
getch(); 
} 
Program 12 
Operating System Lab Manual  
Implement the following Disk Scheduling Algorithms: 
a) SSTF Scheduling    b) SCAN Scheduling   
SSTF Scheduling     
SSTF stands for Shortest Time First which very uses full of learning about how the disk drive 
manages the data having the shortest seek time. 
Algorithm: 
1. Let Request array represents an array storing indexes of tracks that have been requested. 
‘head’ is the position of disk head. 
2. Find the positive distance of all tracks in the request array from head. 
3. Find a track from requested array which has not been accessed/serviced yet and has 
minimum distance from head. 
4. Increment the total seek count with this distance. 
5. Currently serviced track position now becomes the new head position. 
6. Go to step 2 until all tracks in request array have not been serviced. 
#include<stdio.h> 
#include<conio.h> 
#include<math.h> 
int main() 
{ 
int queue[100],t[100],head,seek=0,n,i,j,temp; 
float avg; 
// clrscr(); 
printf("*** SSTF Disk Scheduling Algorithm ***\n"); 
printf("Enter the size of Queue\t"); 
scanf("%d",&n); 
printf("Enter the Queue\t"); 
for(i=0;i<n;i++) 
{ 
scanf("%d",&queue[i]); 
} 
Operating System Lab Manual  
printf("Enter the initial head position\t"); 
scanf("%d",&head); 
for(i=1;i<n;i++) 
t[i]=abs(head-queue[i]); 
for(i=0;i<n;i++) 
{ 
for(j=i+1;j<n;j++) 
{ 
if(t[i]>t[j]) 
{ 
temp=t[i]; 
t[i]=t[j]; 
t[j]=temp; 
temp=queue[i]; 
queue[i]=queue[j]; 
queue[j]=temp; 
} 
} 
} 
for(i=1;i<n-1;i++) 
{ 
seek=seek+abs(head-queue[i]); 
head=queue[i]; 
} 
printf("\nTotal Seek Time is%d\t",seek); 
avg=seek/(float)n; 
printf("\nAverage Seek Time is %f\t",avg); 
return 0; 
} 
OUTPUT: 
*** SSTF Disk Scheduling Algorithm *** 
Enter the size of Queue 5 
Enter the Queue 10 17 2 15 4 
Enter the initial head position 3 
Operating System Lab Manual  
Total Seek Time is14 
Average Seek Time is 2.800000 
RESULT: 
Thus the program was executed and verified successfully. 
Program 13: 
SCAN Scheduling   
SCAN DISK SCHEDULING ALGORITHM  
#include<stdio.h>  
main()  
{ 
int t[20], d[20], h, i, j, n, temp, k, atr[20], tot, p, sum=0;  
clrscr(); 
printf("enter the no of tracks to be traveresed");  
scanf("%d'",&n); 
printf("enter the position of head"); 
scanf("%d",&h);  
t[0]=0;t[1]=h;  
printf("enter the tracks");  
for(i=2;i<n+2;i++)  
scanf("%d",&t[i]); 
for(i=0;i<n+2;i++) 
{  
for(j=0;j<(n+2)-i-1;j++)  
{ 
if(t[j]>t[j+1]) 
{  
temp=t[j];  
t[j]=t[j+1];  
t[j+1]=temp; 
} 
Operating System Lab Manual  
} 
}  
for(i=0;i<n+2;i++) 
if(t[i]==h) 
j=i; 
k=i; 
p=0;  
while(t[j]!=0)  
{  
atr[p]=t[j]; 
j--;  
p++;  
}  
atr[p]=t[j]; 
for(p=k+1;p<n+2;p++,k++)  
atr[p]=t[k+1]; 
for(j=0;j<n+1;j++) 
{  
if(atr[j]>atr[j+1])  
d[j]=atr[j]-atr[j+1]; 
else  
d[j]=atr[j+1]-atr[j];  
sum+=d[j]; 
}  
printf("\nAverage header movements:%f",(float)sum/n);  
getch(); 
}  
INPUT 
Enter no.of tracks:9  
Enter track position:55 58 60 70 18 90 150 160 184  
OUTPUT: 
Tracks Traversed  
150               
Difference Between tracks 
50 
Operating System Lab Manual  
 
 
160    10 
184    24 
90    94 
70    20 
60    10 
58    2 
55    3 
18    37 
 
Program 14: 
 
Implement the following File Allocation Strategies 
                 a) Sequential   b) Indexed    
 
OBJECTIVE Write a C program to simulate the following file allocation strategies. 
a) Sequential b) Indexed 
 
DESCRIPTION A file is a collection of data, usually stored on disk. As a logical entity, a 
file enables to divide data into meaningful groups. As a physical entity, a file should be 
considered in terms of its organization. The term "file organization" refers to the way in which 
data is stored in a file and, consequently, the method(s) by which it can be accessed.  
 
SEQUENTIAL FILE ALLOCATION In this file organization, the records of the file are 
stored one after another both physically and logically. That is, record with sequence number 
16 is located just after the 15th record. A record of a sequential file can only be accessed by 
reading all the previous records. 
 
INDEXED FILE ALLOCATION Indexed file allocation strategy brings all the pointers 
together into one location: an index block. Each file has its own index block, which is an array 
of disk-block addresses. The ith entry in the index block points to the ith block of the file. The 
directory contains the address of the index block. To find and read the ith block, the pointer in 
the ith index-block entry is used. 
 
SEQUENTIAL FILE ALLOCATION 
Operating System Lab Manual  
#include<stdio.h> 
#include<conio.h> 
struct fileTable 
{  
char name[20];  
int sb, nob; 
}ft[30];  
void main()  
{  
int i, j, n;  
char s[20];  
clrscr();  
printf("Enter no of files :");  
scanf("%d",&n);  
for(i=0;i<n;i++) 
{  
printf("\nEnter file name %d :",i+1);  
scanf("%s",ft[i].name);  
printf("Enter starting block of file %d :",i+1);  
scanf("%d",&ft[i].sb);  
printf("Enter no of blocks in file %d :",i+1);  
scanf("%d",&ft[i].nob);  
}  
printf("\nEnter the file name to be searched -- ");  
scanf("%s",s);  
for(i=0;i<n;i++)  
if(strcmp(s, ft[i].name)==0) 
break;  
if(i==n)  
printf("\nFile Not Found");  
else  
{  
printf("\nFILE NAME START BLOCK NO OF BLOCKS BLOCKS OCCUPIED\n");  
printf("\n%s\t\t%d\t\t%d\t",ft[i].name,ft[i].sb,ft[i].nob);  
Operating System Lab Manual  
for(j=0;j<ft[i].nob;j++) 
printf("%d, ",ft[i].sb+j); 
}  
getch(); 
}  
INPUT: Enter no of files :3 
Enter file name 1 :A  
Enter starting block of file 1 :85  
Enter no of blocks in file 1 :6  
Enter file name 2 :B  
Enter starting block of file 2 :102 
Enter no of blocks in file 2 :4  
Enter file name 3 :C  
Enter starting block of file 3 :60  
Enter no of blocks in file 3 :4  
Enter the file name to be searched -- B  
OUTPUT:  
FILE NAME     START BLOCK    NO OF BLOCKS        
B                           
Program 15 
102                              
INDEXED FILE ALLOCATION 
#include<stdio.h>  
#include<conio.h>  
struct fileTable  
{  
char name[20]; 
int nob, blocks[30]; 
}ft[30];  
void main()  
BLOCKS OCCUPIED 
4                                  102, 103, 104, 105 
{  
Operating System Lab Manual  
int i, j, n;  
char s[20]; 
clrscr();  
printf("Enter no of files :"); 
scanf("%d",&n); 
for(i=0;i<n;i++) 
{  
printf("\nEnter file name %d :",i+1);  
scanf("%s",ft[i].name); 
printf("Enter no of blocks in file %d :",i+1);  
scanf("%d",&ft[i].nob);  
printf("Enter the blocks of the file :");  
for(j=0;j<ft[i].nob;j++)  
scanf("%d",&ft[i].blocks[j]); 
}  
printf("\nEnter the file name to be searched -- ");  
scanf("%s",s);  
for(i=0;i<n;i++)  
if(strcmp(s, ft[i].name)==0)  
break;  
if(i==n)  
printf("\nFile Not Found");  
else  
{  
printf("\nFILE NAME NO OF BLOCKS BLOCKS OCCUPIED");  
printf("\n %s\t\t%d\t",ft[i].name,ft[i].nob);  
for(j=0;j<ft[i].nob;j++) 
printf("%d, ",ft[i].blocks[j]);  
}  
getch(); 
} 


INPUT:  
Operating System Lab Manual  
Enter no of files : 2  
Enter file 1 : A  
Enter no of blocks in file 1 : 4  
Enter the blocks of the file 1 : 12 23 9 4  
Enter file 2 : G  
Enter no of blocks in file 2: 5  
Enter the blocks of the file 2: 88 77 66 55 44 
Enter the file to be searched: G  
OUTPUT:  
FILE NAME       
G                        
NO OF BLOCKS                        
5                                                   
BLOCKS OCCUPIED    
88, 77, 66, 55, 44 13 
